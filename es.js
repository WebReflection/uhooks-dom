self.uhooksDOM=function(e){"use strict";function t(e){this.observe(e,{subtree:!0,childList:!0})}function n(e){e.type in this&&this[e.type](e)}let s=null,o=new Set;const c=e=>{const{$:t,r:n,h:s}=e;f(n)&&(a.get(s).delete(e),n()),f(e.r=t())&&a.get(s).add(e)},r=()=>{const e=o;o=new Set,e.forEach((({h:e,c:t,a:n,e:s})=>{s&&e.apply(t,n)}))},a=new WeakMap,l=[],i=[];function u(e,t){return e!==this[t]}const h=e=>{const t=a.get(e);t&&y.then((()=>{t.forEach((e=>{e.r(),e.r=null,e.d=!0})),t.clear()}))},d=()=>s,p=e=>a.has(e),f=e=>"function"==typeof e,v=e=>{const t={h:n,c:null,a:null,e:0,i:0,s:[]};return n;function n(){const n=s;s=t,t.e=t.i=0;try{return e.apply(t.c=this,t.a=arguments)}finally{s=n,l.length&&y.then(l.forEach.bind(l.splice(0),c)),i.length&&i.splice(0).forEach(c)}}},y=Promise.resolve();function w(e){const{_:t,value:n}=this;n!==e&&(this._=new Set,this.value=e,t.forEach((({h:e,c:t,a:n})=>{e.apply(t,n)})))}const E=(e,t)=>{const n=d(),{i:s,s:o}=n;return s!==o.length&&t&&!t.some(u,o[s]._)||(o[s]={$:e(),_:t}),o[n.i++].$},g=e=>(t,n)=>{const s=d(),{i:o,s:c,h:r}=s,l=o===c.length;s.i++,l&&(a.has(r)||a.set(r,new Set),c[o]={$:t,_:n,r:null,d:!1,h:r}),(l||!n||c[o].d||n.some(u,c[o]._))&&e.push(c[o]),c[o].$=t,c[o]._=n,c[o].d=!1},m=g(l),k=g(i),M=(e,t)=>f(t)?t(e):t,S=(e,t,n)=>{const s=d(),{i:c,s:a}=s;c===a.length&&a.push({$:f(n)?n(t):M(void 0,t),set:t=>{a[c].$=e(a[c].$,t),(e=>{o.has(e)||(e.e=1,o.add(e),y.then(r))})(s)}});const{$:l,set:i}=a[s.i++];return[l,i]};
/*! (c) Andrea Giammarchi - ISC */
let $=null,_=null,b=null;const C=new WeakMap,W=new WeakMap,L=(e,t,n,s)=>{const o=o=>{C.has(e)||(C.set(e,0),y.then((()=>{C.delete(e),e.apply(t,n)}))),s(o)};return W.set(s,o),o},x=(e,t,n,s)=>e?[s[0],W.get(s[1])||L(e,t,n,s[1])]:s,O=(e,t)=>{const n=v(t?function(){const[t,s,o]=[$,_,b];[$,_,b]=[n,this,arguments];try{return e.apply(_,b)}finally{[$,_,b]=[t,s,o]}}:e);return n},N=((e,s,o,c)=>{const r=new WeakMap,a=new WeakMap,l=new WeakMap,i=e=>r.has(e),u=e=>{i(e)&&(h(e,e.removeEventListener,r.get(e)),r.delete(e))},h=(e,t,n)=>{t.call(e,"disconnected",n),t.call(e,"connected",n)},d=(e,t,n,s)=>{for(let{length:o}=e,c=0;c<o;c++)p(e[c],t,n,s)},p=(e,t,n,c)=>{i(e)&&!n.has(e)&&(c.delete(e),n.set(e,0),e.dispatchEvent(new(o||CustomEvent)(t))),d(e[s||"children"]||[],t,n,c)},f=new(c||MutationObserver)((e=>{for(let{length:t}=e,n=0;n<t;n++){const{removedNodes:t,addedNodes:s}=e[n];d(t,"disconnected",l,a),d(s,"connected",a,l)}}));f.add=t,f.add(e||document);const{attachShadow:v}=Element.prototype;return v&&(Element.prototype.attachShadow=function(e){const t=v.call(this,e);return f.add(t),t}),{has:i,connect:(e,t)=>{u(e),(t||(t={})).handleEvent||(t.handleEvent=n),h(e,e.addEventListener,t),r.set(e,t)},disconnect:u,kill(){f.disconnect()}}})(document,"children",CustomEvent),R=({firstChild:e})=>{if(e&&1!==e.nodeType&&!(e=e.nextElementSibling))throw"unobservable";return e},T=e=>{const{nodeType:t}=e;if(t)return 1===t?e:R(e);{const t=e.valueOf();return t!==e?T(t):R(t)}};return e.createContext=e=>({_:new Set,provide:w,value:e}),e.hooked=(e,t)=>{const n=O(e,t);return function(){const e=n.apply(this,arguments);if(p(n)){const t=T(e);N.has(t)||N.connect(t,{disconnected(){h(n)}})}return e}},e.useCallback=(e,t)=>E((()=>e),t),e.useContext=({_:e,value:t})=>(e.add(d()),t),e.useEffect=m,e.useLayoutEffect=k,e.useMemo=E,e.useReducer=(e,t,n)=>x($,_,b,S(e,t,n)),e.useRef=e=>{const t=d(),{i:n,s:s}=t;return n===s.length&&s.push({current:e}),s[t.i++]},e.useState=e=>x($,_,b,(e=>S(M,e))(e))
/*! (c) Andrea Giammarchi - ISC */,e.wait=y,e}({});
